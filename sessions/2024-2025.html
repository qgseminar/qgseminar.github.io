<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2024-2025 – QGS</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-914ee4f9c63d60221354e1c2dee7045e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../static/css/styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">QGS</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../current.html"> 
<span class="menu-text">Current session</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-past-sessions" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Past sessions</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-past-sessions">    
        <li>
    <a class="dropdown-item" href="../sessions/2024-2025.html">
 <span class="dropdown-text">Session 2024-2025</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../sessions/2023-2024.html">
 <span class="dropdown-text">Session 2023-2024</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../sessions/2022-2023.html">
 <span class="dropdown-text">Session 2022-2023</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../sessions/2021-2022.html">
 <span class="dropdown-text">Session 2021-2022</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../sessions/2020-2021.html">
 <span class="dropdown-text">Session 2020-2021</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../events.html"> 
<span class="menu-text">Events &amp; Opportunities</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">2024-2025</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="session-20242025" class="level1 small-caps text-center">
<h1 class="small-caps">Session 2024–2025</h1>
</section>
<section id="autumn-session" class="level1">
<h1>Autumn Session</h1>
<details>
<summary>
<strong>Jean Delhaye (Université Paris-Saclay)</strong> - November 18, 2024
</summary>
<ul>
<li><p><strong>Title</strong>: Cutoff for the Brownian Motion on the Unitary Quantum Group.</p></li>
<li><p><strong>Abstract</strong>: We introduce an analog of the Brownian motion on free unitary quantum groups <span class="math inline">\(UN+\)</span>​. We will discuss the construction of this Brownian motion, computing its cutoff, where convergence to equilibrium undergoes a sharp transition. We will also examine the cutoff profile, analyzing the fine-scale behavior of the total variation distance around the cutoff. Unlike classical or orthogonal quantum groups, the study of <span class="math inline">\(UN+\)</span>​ has additional challenges, such as non-absolute continuity, distinct properties of its central algebra and inabilities to clearly identify a Brownian motion.</p></li>
<li><p><a href="../slides/2024-2025/1Autumn Session 2024-2025/Talk1 - JeanDelhaye (18-11-2024).pdf"><strong>Slides</strong></a></p></li>
</ul>
</details>
<details>
<summary>
<strong>Malte Leimbach (Radboud University)</strong> - December 16, 2024
</summary>
<ul>
<li><p><strong>Title</strong>: Convergence of Peter–Weyl Truncations of Compact Quantum Groups.</p></li>
<li><p><strong>Abstract</strong>: A fundamental principle of noncommutative geometry is to encode geometric information by spectral data, formalised in the notion of spectral triples. In physical practice there are, however, always obstructions on the availability of such data, and one might be led to considering truncated versions of spectral triples instead. In this talk we will take a closer look at this formalism and explore it within the framework of compact quantum metric spaces. In particular we will consider compact quantum groups as compact quantum metric spaces when equipped with an invariant lip-norm. We will discuss complete Gromov–Hausdorff convergence of truncations arising from the Peter–Weyl decomposition of a compact quantum group.</p></li>
<li><p><a href="../slides/2024-2025/1Autumn Session 2024-2025/Talk2 - MalteLeimbach (16-12-2024).pdf"><strong>Slides</strong></a></p></li>
</ul>
</details>
</section>
<section id="winter-session" class="level1">
<h1>Winter Session</h1>
<details>
<summary>
<strong>Julio Cáceres (Vanderbilt University)</strong> - February 3, 2025
</summary>
<ul>
<li><p><strong>Title</strong>: New hyperfinite subfactors with infinite depth.</p></li>
<li><p><strong>Abstract</strong>: We will present new examples of irreducible, hyperfinite subfactors with trivial standard invariant and interesting Jones indices. These are obtained by constructing new finite dimensional commuting squares. We will use two graph planar algebra embedding theorems and the classification of small index subfactors to show that our commuting square subfactors cannot have finite depth. We also present one-parameter families of commuting squares that, by a classification result of Kawahigashi, will also yield irreducible infinite depth subfactors. This is joint work with Dietmar Bisch.</p></li>
<li><p><a href="../slides/2024-2025/2Winter Session 2024-2025/Talk1 - JulioCaceresGonzales (03-02-2025).pdf"><strong>Slides</strong></a></p></li>
</ul>
</details>
<details>
<summary>
<strong>Roberto Hernández Palomares (University of Waterloo)</strong> - March 17, 2025
</summary>
<ul>
<li><p><strong>Title</strong>: Quantum graphs, subfactors and tensor categories.</p></li>
<li><p><strong>Abstract</strong>: We will introduce equivariant graphs with respect to a quantum symmetry along with examples such as classical graphs, Cayley graphs of finite groupoids, and their quantum analogues. These graphs can be presented concretely by modeling a quantum vertex set by an inclusion of operator algebras and the quantum edge set by an equivariant endomorphism, idempotent with respect to convolution/Schur product. Equipped with this viewpoint and tools from subfactor theory, we will see how to obtain all these idempotents using higher relative commutants and the quantum Fourier transform. Finally, we will state a quantum version of Frucht’s Theorem, showing that every quasitriangular finite quantum groupoid arises as certain automorphisms of some categorified graph.</p></li>
<li><p><a href="../slides/2024-2025/2Winter Session 2024-2025/Talk2 - RobertoHernandezPalomares (17-03-2025).pdf"><strong>Slides</strong></a></p></li>
</ul>
</details>
</section>
<section id="spring-session" class="level1">
<h1>Spring Session</h1>
<details>
<summary>
<strong>Sang-Gyun Youn (Seoul National University)</strong> - March 31, 2025 <strong>at 10:00 am (CEST)</strong>
</summary>
<ul>
<li><p><strong>Title</strong>: A Khintchine inequality for central Fourier series on non-Kac compact quantum groups.</p></li>
<li><p><strong>Abstract</strong>: The study of Khintchine inequalities has a long history in abstract harmonic analysis. While there is almost no possibility of non-trivial Khintchine inequality for central Fourier series on compact connected semisimple Lie groups, it has turned out that a strong contrast holds within the framework of compact quantum groups. Specifically, a Khintchine inequality with operator coefficients is proved for arbitrary central Fourier series in a large class of non-Kac compact quantum groups. The main examples include the Drinfeld-Jimbo <span class="math inline">\(q\)</span>-deformations, the free orthogonal quantum groups, and the quantum automorphism groups.</p></li>
</ul>
</details>
<details>
<summary>
<strong>Heon Lee (Harbin Institute of Technology)</strong> - April 7, 2025
</summary>
<ul>
<li><p><strong>Title</strong>: First-order differential calculi and Laplacians on <span class="math inline">\(q\)</span>-deformations of compact semisimple Lie groups.</p></li>
<li><p><strong>Abstract</strong>: In this talk, we suggest a simple definition of Laplacian on a compact quantum group (CQG) associated with a first-order differential calculus (FODC) on it. Applied to the classical differential calculus on a compact Lie group, this definition yields classical Laplacians, as it should. Moreover, on the CQG <span class="math inline">\(K_q\)</span> arising from the <span class="math inline">\(q\)</span>-deformation of a compact semisimple Lie group <span class="math inline">\(K\)</span>, we can find many interesting linear operators that satisfy this definition, which converge to a classical Laplacian on <span class="math inline">\(K\)</span> as <span class="math inline">\(q\)</span> tends to <span class="math inline">\(1\)</span>. In the light of this, we call them <span class="math inline">\(q\)</span>-Laplacians on <span class="math inline">\(K_q\)</span> and investigate some of their operator theoretic properties. In particlar, we show that the heat semigroups generated by these are not completely positive, suggesting that perhaps on the CQG <span class="math inline">\(K_q\)</span>, stochastic processes that are most relevant to the geometry of it are not quantum Markov processes. This work is based on the preprint arXiv:2410.00720.</p></li>
<li><p><a href="../slides/2024-2025/3Spring Session 2024-2025/Talk2 - HeonLee (07-04-2025).pdf"><strong>Slides</strong></a></p></li>
</ul>
</details>
<details>
<summary>
<strong>Hua Wang (Harbin Institute of Technology)</strong> - April 14, 2025
</summary>
<ul>
<li><p><strong>Title</strong>: A Theory of Locally Convex Hopf Algebras – I. Basic Theory and Examples.</p></li>
<li><p><strong>Abstract</strong>: This is the first of two talks on a recent theory of locally convex Hopf algebras. After a brief introduction to some relevant facts on locally convex spaces as well as their topological tensor products, we will describe the main theory with an emphasis on duality. We will see that besides the usual strong dual, the theory encompasses naturally a new type of dual called the polar dual. After presenting the main theoretical results, we will illustrate the theory with various examples. In particular, we will see how to resolve the duality problem for classical Hopf algebras, how to describe a Lie group as well as its dual using smooth functions, and how to incorporate compact and discrete quantum groups into this framework.</p></li>
</ul>
</details>
<details>
<summary>
<strong>Hua Wang (Harbin Institute of Technology)</strong> - April 21, 2025
</summary>
<ul>
<li><p><strong>Title</strong>: A Theory of Locally Convex Hopf Algbebras – II. More Duality Results and Examples.</p></li>
<li><p><strong>Abstract</strong>: This is the second of two talks on a recent theory of locally convex Hopf algebras. We will start by presenting a generalized version of the Gelfand duality, and later apply it in various situations to obtain the underlying topological group from the corresponding locally convex Hopf algebras. Surprisingly, we can go much beyond the locally compact case in this classical situation, and make the theory work for all topological groups with compactly generated topology. Then we shift to some categorical considerations, allowing us to obtain new topological quantum groups as well as their dualities that seem not in the locally compact framework of Kustermans-Vaes. If time permits, we will conclude by mentionning how some deep structural results related to Hilbert’s fifth problem can be applied in this theory.</p></li>
</ul>
</details>
<details>
<summary>
<strong>Farrokh Razavinia (Non Resident Researcher at IPM)</strong> - May 19, 2025
</summary>
<ul>
<li><p><strong>Title</strong>: <span class="math inline">\(C^*\)</span>-graph algebras and beyond.</p></li>
<li><p><strong>Abstract</strong>: Graph <span class="math inline">\(C^*\)</span>-algebras have shown their importance in mathematics and other disciplines. For instance, recall the theory of quantum groups and quantum graphs, they can provide us with required structures in proving or disproving some interrelated problems. For example, in our recent papers, we showed their importance in looking at some very well-known wonder questions in mathematics from a different direction. In this talk, we will present some elementary definitions and results concerning graph <span class="math inline">\(C^*\)</span>-algebras, and then we will try to study some constructive examples, and after that we will take a look at the concept of <span class="math inline">\(C^*\)</span>-colored graph algebras, and finally we will see how these structures will help us to move into some very abstract mathematical objects!</p></li>
<li><p><a href="../slides/2024-2025/3Spring Session 2024-2025/Talk5 - FarrokhRazavinia (19-05-2025).pdf"><strong>Slides</strong></a></p></li>
</ul>
</details>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© 2020 | QGS team</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>